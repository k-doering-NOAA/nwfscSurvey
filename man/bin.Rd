% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bin.R
\name{bin}
\alias{bin}
\alias{add_bin}
\title{Count observations in each bin by group}
\usage{
bin(data, ..., var, bins, sep = "_")

add_bin(data, ..., var, bins, sep = "_")
}
\arguments{
\item{data}{A data frame to be processed.}

\item{...}{<\link[dplyr:dplyr_data_masking]{dplyr::dplyr_data_masking}>
Variables to group by, i.e., passed to \code{\link[dplyr:group_by]{dplyr::group_by()}}.
Must be valid, unquoted column names present in \code{data}.}

\item{var}{<\link[dplyr:dplyr_data_masking]{dplyr::dplyr_data_masking}>
A variable, without quotes, that is passed to \code{cut(x = data[[var]])},
which divides the data into intervals based on \code{bins} and codes each row
according to the interval in which it falls.
Must be a valid column present in \code{data}.}

\item{bins}{A vector of two or more numerical values passed to
\code{cut(breaks = bins, right = FALSE, include.lowest = TRUE)}
to determine the intervals that \code{var} binned by.
The first value will be the left limit of the first bin,
which will be a closed interval to include values equal to the input.
The last value will be the right limit of the last bin,
which will be a closed interval to include values equal to the input.
Many people like to add \code{-999} and \code{Inf} to the beginning and end of
the input vector to ensure that all positive values will be assigned
a bin rather than \code{NA}.
See the details section or \code{?cut} for more information.}

\item{sep}{A string used to paste together other strings using
\code{\link[=paste]{paste()}}.  We recommend using a distinct, i.e., rarely used,
string such that pattern matching without unnecessary false positives
is easy. For example, when do you ever see \code{..} in a column name?
The default is \code{"_"}.}
}
\value{
A long data frame with
\itemize{
\item a column for each grouping structure passed to \code{...},
\item a column of strings called \code{"{{var}}_bin"}
with the lower and upper limits of the bin, and
\item a column of integers called \verb{\{\{var\}\}_n"}
with the number of observations.
Missing observations for each grouping structure are included in
the final output with a count of \code{0L} using \code{count(.drop = FALSE)}.
If \code{add_bin()} was called, then \verb{\{\{var\}\}_bin"} and \verb{\{\{var\}\}_n"}
are added to \code{data}.
}
}
\description{
\code{bin()} lets you quickly count the number of observations within defined
bins per group.
This is similar to \code{\link[dplyr:count]{dplyr::count()}} but on a newly-created,
dynamically-named column containing the binning categories.

\code{bin_add()} is equivalent to \code{bin()} but uses \code{\link[dplyr:mutate]{dplyr::mutate()}} instead of
\code{\link[dplyr:summarise]{dplyr::summarise()}}. So, it adds two columns to the original data frame,
rather than summarizing the returned data frame to the group levels.
}
\details{
The code for \code{bin()} is roughly equivalent to

\if{html}{\out{<div class="sourceCode">}}\preformatted{  data \%>\%
    group_by(...) \%>\%
    mutate("\{\{var\}\}_bin" := cut()) \%>\%
    summarise("\{\{var\}\}_n" := n())`
}\if{html}{\out{</div>}}

The names of the two new columns are dynamically created by pasting the
string version of \code{var} with \code{"_bin"} and \code{"_n"}. This should help your
future self know what variable the bins and counts are summarizing and
it is also necessary because \code{\link[dplyr:count]{dplyr::count()}} will not work if there
is already a column in \code{data} called \code{"n"}. Thus, the dynamic naming
allows you to summarize multiple biological variables by running
\code{add_bin()} more than once.

\code{bin()} uses \code{\link[=cut]{cut()}} to determine the interval for each row.
\code{cut(right = FALSE, include.lowest = TRUE)} is hard coded, ensuring bins
are closed on the left and open on the right, e.g., \verb{"[0,20)}.
Except for the last bin, which is closed on the right.
For open intervals, indicated using round brackets or parentheses,
the endpoint is not included in the interval.
For closed intervals, indicated using square brackets,
the endpoint is included in the interval.
Thus,
\verb{[0,} describes the left side of an interval greater than or equal to 0 and
\verb{,20)} describes the right side of an interval less than 20.
This notation of round and square brackets is used to name the bins such
that the lower and upper limits of the bins are clear.
}
\examples{
# A simple example with the iris dataset that groups Sepal.Length
# by Species and 2 bins
data(iris, package = "datasets")
bin(data = iris, Species, var = Sepal.Length, bins = c(0, 5, Inf))

# Simple example of add_bin() that adds 2 columns to data
# (result has same number of rows as data)
simple <- add_bin(
  data.frame(x = rep(1:5, 2)),
  var = x,
  bins = c(0, 5, Inf)
)
NROW(simple) == 10
colnames(simple)

# Remaining examples use the {nwfscSurvey} biological data
# Summarize lengths in bins by Year and Sex (result has < rows than input)
# Final bin [200,Inf] is a plus group with all measurements 200 cm and above
summary <- bin(
  data = bio_nwfsc_combo,
  Year, Sex = codify_sex(Sex),
  var = Length_cm,
  bins = c(seq(0, 200, by = 20), Inf)
)
# Equal number of rows per bin because missing observations per group are
# filled in and sum of counts should equal the number of rows of data
dplyr::count(summary, Length_cm_bin)
sum(summary[["Length_cm_n"]]) == NROW(bio_nwfsc_combo)

# add_bin() works like dplyr::mutate() instead of dplyr::summarise()
# (result has same number of rows as input)
original <- add_bin(
  data = bio_nwfsc_combo \%>\% group_by(Year, Sex = codify_sex(Sex)),
  var = Length_cm,
  bins = seq(0, 300, by = 20)
)
# The following have different counts per bin because bins in original
# are closed on the right and open on the left and when we use bespoke
# dplyr code here, the bins are open on right.
bio_nwfsc_combo \%>\%
 dplyr::mutate(bin = cut(Length_cm, breaks = seq(0, 300, by = 20))) \%>\%
 group_by(Year, Sex = codify_sex(Sex), bin) \%>\%
 pull(bin) \%>\% table(., useNA = "always")
table(original[["Length_cm_bin"]])
sum(bio_nwfsc_combo$Length_cm < 20, na.rm = TRUE)
sum(bio_nwfsc_combo$Length_cm <= 20, na.rm = TRUE)

# clean up
# rm(summary, original, simple)

}
\seealso{
Other dplyr verbs: 
\code{\link{quantify}()}
}
\author{
Kelli F. Johnson
}
\concept{dplyr verbs}
